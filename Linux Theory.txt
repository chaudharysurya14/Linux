
Introduction to Linux

        Linux is an open-source operating system that is widely used for servers, desktop computers, and other devices.
         It is based on the Linux kernel, which was first released in 1991 by Linus Torvalds.

        One of the main advantages of Linux is that it is highly customizable and there are many different distributions 
        (also called "distros") available, each with its own unique features and user interface. Some popular Linux distros 
        include Ubuntu, Fedora, and Debian.

        Linux is also known for its security and stability, as well as its ability to run on a wide range of hardware platforms. 
        It is often used in enterprise environments and has a large and active community of users and developers.

        If you are new to Linux, some good places to start learning are with a beginner-friendly distro like Ubuntu, 
        and by working through some online tutorials or taking a course. There are also many resources available online, 
        such as forums and documentation, where you can ask questions and learn more about using Linux.

Getting Acquainted with the Linux Environment

        To get started with the Linux environment, there are a few basic things you should know.

        The terminal: This is a command line interface that allows you to interact with the operating system using text commands. 
        You can use the terminal to navigate the file system, run programs, and perform many other tasks.

        File system: Linux organizes files and directories in a hierarchical structure, starting from the root directory (/). 
        You can use the terminal to navigate the file system and view the contents of directories.

        Commands: The terminal allows you to enter commands to perform various tasks. Some basic commands include "ls" to 
        list the files in a directory, "cd" to change directories, and "pwd" to show the current directory.

        Package management: Most Linux distributions come with a package manager, which allows you to install, update, and 
        remove software packages. Popular package managers include apt (for Debian-based systems) and yum (for Red Hat-based systems).

        Text editor: You will need a text editor to create and edit files in the Linux environment. Some popular text editors 
        include vi, emacs, and nano.

There are many other aspects of the Linux environment, but these are some of the basics to get you started. 


        ls: Lists the files in a directory
        cp: Copies a file or directory
        mv: Moves or renames a file or directory
        lpr: Sends a file to a printer
        sort: Sorts the lines of a file
        grep: Searches for a pattern in a file
        cat: Displays the contents of a file
        tac: Displays the contents of a file in reverse order
        more: Displays the contents of a file one page at a time
        head: Displays the first few lines of a file
        tail: Displays the last few lines of a file
        man: Displays the manual for a command
        whatis: Displays a short description of a command
        whereis: Shows the location of a command
        locate: Searches for a file
        find: Searches for a file or directory
        diff: Shows the differences between two files
        file: Shows the type of a file
        rm: Removes a file
        mkdir: Creates a new directory
        rmdir: Removes an empty directory
        cd: Changes the current directory
        pwd: Prints the current working directory
        ln: Creates a symbolic link
        ln -s: Creates a symbolic link
        gzip: Compresses a file
        gunzip: Uncompresses a file
        zip: Compresses a file
        unzip: Uncompresses a file
        tar: Archives and compresses files
        zcat: Displays the contents of a compressed file
        cal: Shows a calendar
        bc: A calculator
        bc -l: A calculator with support for arbitrary precision arithmetic
        banner: Prints a message in large letters
        date: Shows the current date and time
        time: Shows the current time
        wc: Counts the number of lines, words, and characters in a file
        touch: Creates a new file or updates the timestamp of an existing file
        echo: Prints a message
        who: Shows who is logged in
        finger: Shows information about a user
        w: Shows who is logged in and what they are doing
        whoami: Shows the current user's username
        who am i: Shows the current user's username
        alias: Creates an alias for a command
        unalias: Removes an alias
        touch: Creates a new file or updates the timestamp of an existing file
        push: Saves the current directory on a stack
        pop: Returns to the last directory saved on the stack
        jobs: Shows the jobs that are running in the background
        ps: Shows the processes that are running

The Linux File System


        The Linux file system is organized into a hierarchy, starting from the root directory (/) and branching out into subdirectories.

        At the top level, you will usually find directories such as:

        /bin: This directory contains binary executables that are needed by the system and users.

        /boot: This directory contains files needed to boot the system, such as the Linux kernel.

        /dev: This directory contains special files that represent devices such as hard drives and printers.

        /etc: This directory contains configuration files for the system and installed programs.

        /home: This directory contains the home directories for users. Each user has their own subdirectory under /home.

        /lib: This directory contains library files that are needed by the system and installed programs.

        /media: This directory is used to mount removable media such as USB drives and CDs.

        /mnt: This directory is used to mount file systems temporarily.

        /opt: This directory contains optional software that is not part of the default installation.

        /proc: This directory contains virtual files that provide information about the system and running processes.

        /root: This is the home directory for the root user.

        /sbin: This directory contains system executables that are needed for system maintenance.

        /tmp: This directory contains temporary files that are deleted when the system is rebooted.

        /usr: This directory contains user-level software and data, such as applications and libraries.

        /var: This directory contains files that change frequently, such as logs and databases.


Disk Partition 

        In a computer, a disk partition is a section of a hard drive that is treated as a separate unit. Disk partitions
         are used to organize the hard driveand to allow multiple operating systems to be installed on a single physical hard drive.

        Each partition is formatted with a specific file system and is given a letter to identify
         it (e.g. C: on Windows systems). The root directory of a partition is the top-level directory of
         that file system, and all other directories and files on the partition are organized beneath it.

        In Linux, you can use the fdisk command to view and modify disk partitions. The fdisk command allows you 
        to create, delete, and resize partitions, as well as change the type of a partition.

        It is important to be careful when working with disk partitions, as mistakes can result in data loss.
         It is always a good idea to back up important data before making any changes to the partition table.
 
 Working with Files and Directories
 
         Here are some basic commands that you can use to work with files and directories in a Linux system:

        ls: Lists the files and directories in the current directory
        cd: Changes the current directory
        pwd: Prints the current working directory
        mkdir: Creates a new directory
        rmdir: Removes an empty directory
        touch: Creates a new file
        cp: Copies a file or directory
        mv: Moves or renames a file or directory
        rm: Removes a file
        cat: Displays the contents of a file
        less: Displays the contents of a file one page at a time
        head: Displays the first few lines of a file
        tail: Displays the last few lines of a file
        grep: Searches for a pattern in a file

        You can use these commands in the terminal to perform various tasks such as navigating the file system, 
        creating and modifying files and directories, and searching for files.

        It is also useful to know some basic file manipulation commands such as chmod to change file permissions 
        and chown to change the owner of a file.

Linux Boot proces

        The Linux boot process involves several steps that occur when a Linux system is started. Here is a general overview
         of the process:

        BIOS: When the system is turned on, the BIOS (Basic Input/Output System) performs a power-on self-test (POST) and
         then loads the bootloader from the boot device.

        Bootloader: The bootloader is responsible for loading the operating system kernel into memory and starting it. 
        The most common bootloader for Linux systems is GRUB (GRand Unified Bootloader).

        Kernel: The kernel is the core of the operating system and is responsible for managing the system's resources 
        and interacting with hardware. Once the kernel is loaded, it initializes the system and mounts the root file system.

        Init system: The init system is responsible for starting and managing system services and user processes. 
        The most common init systems for Linux are Systemd and Upstart.

        System services: The init system starts various system services, such as the network stack, logging daemon, 
        and filesystem mounting.

        Login: Once the system is fully initialized, the login prompt is displayed, and the user can log in to the system.

Startup files

        Startup files are scripts or configuration files that are executed or sourced when a Linux system 
        is booted or a user logs in. These files can be used to customize the environment and set up the system to
         meet the user's needs.

        Here are some common types of startup files:

        /etc/rc.local: This file is executed by the init system during the boot process. It can be used to run custom 
        commands or scripts at startup.

        /etc/profile: This file is sourced by the shell when a user logs in. It can be used to set environment variables 
        and define aliases and functions.

        ~/.bash_profile: This file is similar to /etc/profile, but it is specific to the Bash shell and is only sourced 
        for the current user.

        ~/.bashrc: This file is sourced by the Bash shell every time a new shell is started. It can be used to set
         shell options and define aliases and functions.

        ~/.bash_login: This file is similar to ~/.bash_profile, but it is only sourced if ~/.bash_profile is not found.

        ~/.bash_logout: This file is executed by the Bash shell when a user logs out. It can be used to perform cleanup tasks.

        There are many other startup files that can be used to customize the system, and the specific files and their 
        locations may vary depending on the Linux distribution and the user's preferences.


Installation of Linux operating system

Session 12:


Controlling and managing Services


        In a Linux system, services are programs that run in the background to perform specific functions. 
        Common services include web servers, database servers, and network daemons.

        There are several tools that you can use to control and manage services in a Linux system:

        systemctl: This is the primary tool for managing services on systems that use Systemd as the init system.
         You can use systemctl to start, stop, enable, and disable services.

        service: This is a legacy tool for managing services on systems that use SysVinit or Upstart as the init system. 
        You can use service to start, stop, and restart services.

        initctl: This is a tool for managing services on systems that use Upstart as the init system. You can use 
        initctl to start, stop, and restart services.

        chkconfig: This is a tool for managing services on systems that use SysVinit as the init system. 
        You can use chkconfig to enable or disable services to start at boot time.

        It is important to be careful when modifying the status of services, 
        as this can affect the functionality of the system. It is always a good idea to make sure that you understand
         the consequences of stopping or disabling a service before doing so.
         
 Access control list and chmod command
 
         An access control list (ACL) is a mechanism that allows fine-grained control over access to 
         files and directories in a Linux system. With an ACL, you can set permissions for specific users 
         or groups, in addition to the standard owner, group, and others permissions.

        The chmod command is used to change the permissions of a file or directory. The permissions are 
        represented by a three-digit octal number, where each digit corresponds to the permissions for 
        the owner, group, and others, respectively.

        For example, the command chmod 755 file.txt would set the permissions for file.txt as follows:

        7: The owner has read, write, and execute permissions (rwx).
        5: The group has read and execute permissions (rx).
        5: Others have read and execute permissions (rx).
        To set ACL permissions, you can use the setfacl command. For example, the command setfacl -m u:john:rwx file.txt
         would give the user john read, write, and execute permissions for file.txt.
         

chown and commands
         
         The chown command is used to change the owner and/or group of a file or directory.

        Here is the basic syntax for the chown command:

        
        chown [OPTION]... OWNER[:GROUP] FILE...
        For example, the command chown john file.txt would change the owner of file.txt to john, and the
        command chown john:users file.txt would change the owner to john and the group to users.

        You can also use the -R option to recursively change the owner and/or group of all files and directories
         under a specified directory. For example, the command chown -R john:users /home/john would change the owner
         and group of all files and directories under /home/john to john and users, respectively.

        It is important to note that only the superuser (root) or a user with the CAP_CHOWN capability can use
         the chown command to change the owner of a file.

         
 Network Commands like telnet, ftp, ssh, and sftp, finger:

         
         Here are some common network commands that you can use in a Linux system:

        telnet: This command allows you to connect to a remote system using the Telnet protocol. You can use telnet to 
        remotely log in to a system and execute commands.

        ftp: This command allows you to transfer files to and from a remote system using the FTP (File Transfer Protocol)
         protocol. You can use ftp to upload and download files, as well as list the files on the remote system.

        ssh: This command allows you to securely connect to a remote system using the SSH (Secure Shell) protocol.
         You can use ssh to remotely log in to a system and execute commands.

        sftp: This command allows you to securely transfer files to and from a remote system using the SFTP 
        (Secure File Transfer Protocol) protocol. You can use sftp to upload and download files, as well as list the
         files on the remote system.

        finger: This command allows you to query information about users on a system. You can use finger to display
         information such as the user's login name, real name, and login time.
 
 Overview of Log management
 
        Log management is the process of collecting, storing, and analyzing log files generated by the system and applications.
         Logs are an important source of information that can be used to troubleshoot problems, monitor system activity,
         and track security events.

        In a Linux system, logs are typically stored in the /var/log directory. Some common log files include:

        /var/log/syslog: This file contains system-wide messages, including kernel messages and messages from system services.

        /var/log/auth.log: This file contains messages related to user authentication and authorization.

        /var/log/messages: This file contains miscellaneous system messages, including messages from system services.

        /var/log/kern.log: This file contains kernel messages.

        /var/log/cron: This file contains messages from the cron daemon, which is responsible for running scheduled tasks.

        There are many other log files that may be present on a system, depending on the installed software and services.

        To manage logs, you can use tools such as logrotate to rotate and compress old logs, and rsyslog or syslog-ng to 
        collect and forward logs to a remote server. You can also use log analysis tools such as grep, awk, and sed to extract
         information from log files and generate reports.
 
 Session 13
 
 System Configuration Files
 
         In a Linux system, configuration files are used to store system and application settings. These files are usually
         stored in the /etc directory and its subdirectories.

        Here are some common types of configuration files:

        /etc/fstab: This file contains information about the filesystems that are mounted on the system.

        /etc/passwd: This file contains information about the system's users, including their login names, passwords,
         and home directories.

        /etc/group: This file contains information about the system's groups.

        /etc/shadow: This file contains encrypted passwords for the system's users.

        /etc/hosts: This file contains a mapping of IP addresses to hostnames.

        /etc/resolv.conf: This file contains information about the system's DNS (Domain Name System) configuration.

        /etc/ssh/sshd_config: This file contains the configuration for the SSH (Secure Shell) daemon.

        /etc/httpd/httpd.conf: This file contains the configuration for the Apache HTTP Server.

        It is important to be careful when editing configuration files, as mistakes can result in system problems.
         It is always a good idea to make a backup of a configuration file before making any changes.
         
 
 Network Configuration
 
         In a Linux system, you can use the ifconfig command to view and configure network interfaces. The ifconfig command
         displays information about the system's network interfaces, such as the IP address, netmask, and MAC address.

        Here are some common options for the ifconfig command:

        ifconfig interface up: This option brings the specified interface up.

        ifconfig interface down: This option brings the specified interface down.

        ifconfig interface IP_address: This option assigns the specified IP address to the interface.

        ifconfig interface netmask NETMASK: This option sets the netmask for the interface.

        ifconfig interface broadcast ADDRESS: This option sets the broadcast address for the interface.

        To configure a network interface permanently, you can edit the configuration file for the interface.
         The configuration file is usually located in the /etc/sysconfig/network-scripts directory and has a name such 
         as ifcfg-eth0 for the first Ethernet interface.


Network Monitoring and Troubleshooting (netstat/iproute2)


        netstat is a command-line utility that allows you to view information about the network connections on a Linux system.
        You can use netstat to view a list of active sockets, as well as the status of TCP and UDP connections.

        Here are some common options for the netstat command:

        netstat -a: This option displays all active sockets, including listening sockets.

        netstat -t: This option displays only TCP connections.

        netstat -u: This option displays only UDP connections.

        netstat -n: This option displays addresses and port numbers in numerical form, rather than resolving them to hostnames
         and service names.

        iproute2 is a suite of utilities that allows you to view and manipulate the network routing table, as well as
         configure network interfaces and traffic control. Some common utilities in the iproute2 suite are:

        ip: This utility allows you to view and manipulate the network routing table and configure network interfaces.

        tc: This utility allows you to configure traffic control (QoS) settings.

        ss: This utility allows you to view socket statistics.

        You can use these tools to monitor and troubleshoot network issues on a Linux system.


Session 14 & 15:

Introduction to BASH Command Line Interface (CLI)


        BASH (Bourne Again SHell) is a Unix shell and command-line interface (CLI) that is widely used on Linux systems.
         BASH provides a command-line interface for interacting with the operating system and running programs.

        To use the BASH CLI, you can open a terminal emulator program or log in to a system using a remote shell such as SSH. 
        Once you are at the command prompt, you can enter commands to perform various tasks.

        Here are some basic features of the BASH CLI:

        Command history: You can use the up and down arrow keys to navigate through the history of previously entered commands.

        Command completion: You can use the tab key to automatically complete commands, filenames, and directory names.

        Aliases: You can define aliases for frequently used commands to save time and typing.

        Variables: You can define and use variables to store and manipulate data.

        Redirection: You can redirect the output of a command to a file or pipe it to another command.

        Job control: You can use fg and bg to bring a job to the foreground or background, respectively.


Control Structure, Loop

        Control structures are programming constructs that allow you to control the flow of execution of a program. In the BASH shell, you can use control structures such as if, for, and while to create complex programs and scripts.

        Here is an example of an if statement in BASH:

        Copy code
        if [ condition ]; then
            # commands to execute if the condition is true
        else
            # commands to execute if the condition is false
        fi
        Here is an example of a for loop in BASH:

        Copy code
        for variable in list; do
            # commands to execute for each element in the list
        done
        Here is an example of a while loop in BASH:

        Copy code
        while [ condition ]; do
            # commands to execute while the condition is true
        done
        You can use control structures and loops to create scripts that automate tasks and perform repetitive operations.


Variable & String

        In the BASH shell, you can use variables to store and manipulate data. A variable is a named storage location that holds
         a value.

        To create a variable, you can use the following syntax:

        Copy code
        variable_name=value
        For example, the following command creates a variable called name and assigns it the value John:

        Copy code
        name=John
        You can reference a variable by using the $ symbol followed by the variable name. For example, to print the value 
        of the name variable, you can use the following command:

        Copy code
        echo $name
        In the BASH shell, variables are untyped, which means that a variable can hold any type of data. You can use 
        variables to store strings, numbers, and other types of data.

        To create a string variable, you can enclose the string in quotation marks. For example:

        Copy code
        greeting="Hello, world!"
        You can use the echo command to print the value of a string variable. For example:

        Copy code
        echo $greeting
        You can also use string manipulation commands such as cut, grep, sed, and awk to extract and manipulate substrings.


Create a shell script that will return the following set of system information.
        1. Hostname and Logged-in users
        2. File system disk space usage
        3. Free and used memory
        4. System uptime and Load


        #!/bin/bash

        # Hostname and logged-in users
        echo -e "Hostname: \c"
        hostname
        echo -e "Logged-in users: \c"
        who

        # File system disk space usage
        echo -e "\nFile system disk space usage:"
        df -h

        # Free and used memory
        echo -e "\nFree and used memory:"
        free -m

        # System uptime and load
        echo -e "\nSystem uptime and load:"
        uptime

        chmod +x sysinfo.sh

        ./sysinfo.sh


Session 16 & 17

Error handling is the process of dealing with errors or exceptions that may occur during the execution of a program.
 In the BASH shell, you can use control structures such as if and case to handle errors and exceptions.

        Here is an example of an if statement that checks for an error condition:

        if command; then
            # commands to execute if the command succeeds
        else
            # commands to execute if the command fails
        fi

        You can also use the $? variable to check the exit status of the last command. The exit status is a numerical value 
        that indicates the success or failure of the command. A value of 0 indicates success, and a non-zero value indicates an 
        error.

        Here is an example of using the $? variable to check the exit status:

        if command; then
            # commands to execute if the command succeeds
        else
            # commands to execute if the command fails
            if [ $? -eq 1 ]; then
                # commands to execute if the error is a specific type of error
            fi
        fi

        You can also use the trap command to specify actions to be taken when certain signals are received. 
        This can be useful for handling errors and exceptions in scripts.


Debugging & Redirection of scripts

        There are several techniques that you can use to debug BASH scripts:

        Use the set -x and set +x commands to turn on and off debugging mode. When debugging mode is on, each command 
        in the script will be printed to the terminal before it is executed.

        Use the bash -x script.sh command to run the script with debugging mode enabled.

        Use the bash -n script.sh command to check the syntax of the script without executing it.

        Use the echo command to print variables and the values of intermediate calculations to the terminal.

        Use the trap command to specify actions to be taken when certain signals are received. This can be useful 
        for debugging scripts that are interrupted by signals.

        To redirect the output of a script to a file, you can use the > operator. For example, the following command 
        redirects the output of the sysinfo.sh script to the sysinfo.txt file:

        ./sysinfo.sh > sysinfo.txt

        You can also use the >> operator to append the output to the file, rather than overwriting it.


Conditional Statement Regular Expressions

        In the BASH shell, you can use regular expressions to match patterns in strings. A regular expression is a sequence of
         characters that defines a search pattern.

        Here is an example of using a regular expression with the grep command to search for a pattern in a file:

        grep "pattern" file

        You can use the -E option to enable extended regular expressions, which allows you to use additional metacharacters
         and syntax.

        You can use regular expressions in conditional statements such as if and case to test for patterns in strings.

        Here is an example of using a regular expression in an if statement:

        if [[ "$string" =~ "pattern" ]]; then
            # commands to execute if the pattern is found in the string
        else
            # commands to execute if the pattern is not found in the string
        fi

        Here is an example of using a regular expression in a case statement:

        case "$string" in
            *pattern*)
                # commands to execute if the pattern is found in the string
                ;;
            *)
                # commands to execute if the pattern is not found in the string
                ;;
        esac



Session 18 & 19

Automate Task Using Bash Script

        To automate tasks using Bash scripts, you can create a script that contains a series of commands to be executed in order. 
        You can then use tools such as cron to schedule the script to run automatically at specified intervals or at a specific time.

        Here is an example of a simple Bash script that checks the disk usage and sends an email if the usage exceeds a certain 
        threshold:

        #!/bin/bash

        # Check disk usage
        usage=$(df -h / | grep -v "Filesystem" | awk '{print $5}' | sed 's/%//')

        # Send an email if the usage is above the threshold
        if [ $usage -ge 80 ]; then
            echo "Disk usage is high: $usage%" | mail -s "Disk Usage Alert" user@example.com
        fi

        To schedule the script to run automatically, you can use the cron daemon. cron reads the configuration files in the 
        /etc/cron.* directories and the /var/spool/cron directory and executes commands at the specified times.

        To schedule the script to run daily at 6:00 am, you can add the following line to the /etc/crontab file:

        0 6 * * * root /path/to/script.sh

        This will run the script.sh script as the root user every day at 6:00 am.


Security patches ::


        Security patches are updates that fix vulnerabilities or security issues in software or operating systems. It is important
         to keep your systems up to date with the latest security patches to protect against threats such as malware, viruses, and 
         hackers.

        On a Linux system, you can use package managers such as yum or apt-get to update the system packages and apply security 
        patches.

        To update all packages on a Red Hat-based system (such as CentOS or Fedora) using yum, you can use the following command:


        sudo yum update

        To update all packages on a Debian-based system (such as Ubuntu) using apt-get, you can use the following command:

        sudo apt-get update && sudo apt-get upgrade


        These commands will update the package lists and upgrade any out-of-date packages.

        You can also use a vulnerability scanner such as lynis or nessus to scan your system for vulnerabilities and report any
         missing patches.
 
 Session 20:
 
         Logging & Monitoring using script :
         
         To log and monitor system activity using Bash scripts, you can use tools such as logrotate and rsyslog to manage log 
         files and top, vmstat, and sar to monitor system performance.

        logrotate is a utility that rotates, compresses, and archives system log files. You can use logrotate to configure how 
        often log files are rotated, how many copies are kept, and how the rotated logs are compressed.

        rsyslog is a powerful system logging daemon that can be used to collect, filter, and forward log messages.
         You can use rsyslog to configure rules to specify which log messages to forward and where to send them.

        top is a utility that displays information about the running processes on a system, including the CPU and memory usage. 
        You can use top to monitor system performance and identify resource-intensive processes.

        vmstat is a utility that displays information about the system's memory, CPU, and I/O activity. You can use vmstat to
         monitor system performance and identify bottlenecks.

        sar is a utility that collects and reports system activity statistics. You can use sar to monitor system performance 
        over time and analyze trends.

        You can use these tools in Bash scripts to log and monitor system activity and performance.

Assignments:

        Hands on Linux Commands, Vim Editor 

        Here are some hands-on exercises you can try to practice using Linux commands and the Vim editor:

        Create a directory structure in your home directory using the mkdir command. For example:

        mkdir -p Documents/{Work,School}


        Create some files in the directories using the touch command. For example:

        touch Documents/Work/{file1.txt,file2.txt}
        touch Documents/School/{file1.txt,file2.txt}

        Use the ls and tree commands to list the directories and files.

        Use the cp command to copy a file from one directory to another. For example:

        cp Documents/Work/file1.txt Documents/School/file1.txt

        Use the mv command to move a file from one directory to another. For example:

        mv Documents/Work/file2.txt Documents/School/file2.txt

        Use the rm command to delete a file. For example:

        rm Documents/School/file2.txt

        Use the cat command to display the contents of a file. For example:

        cat Documents/School/file1.txt

        Use the sort command to sort the contents of a file. For example:

        sort Documents/School/file1.txt

        Use the grep command to search for a pattern in a file. For example:

        grep "pattern" Documents/School/file1.txt

        Use the vim editor to create and edit a file. To start vim, type vim followed by the filename. For example:

        vim Documents/School/file2.txt


Creating partitions in Linux OS. :

        To create partitions in a Linux operating system, you can use the fdisk utility. fdisk is a command-line tool that allows you to create, delete, and manage disk partitions.

        Here is an example of how to use fdisk to create a new partition on a disk:

        Identify the disk that you want to partition. You can use the lsblk command to list the available disks.

        Run the fdisk command on the disk. For example:

        sudo fdisk /dev/sdb

        Press p to print the current partition table. This will show you the existing partitions on the disk.

        Press n to create a new partition.

        Select the type of partition you want to create. You can choose between a primary, extended, or logical partition.

        Select the partition number. The default is the lowest available number.

        Enter the start and end sectors for the partition. The default is the first and last sectors of the disk.

        Press w to write the partition table to the disk and exit fdisk.

        Use the mkfs command to create a filesystem on the new partition. For example:

        sudo mkfs.ext4 /dev/sdb1

        This will create an ext4 filesystem on the new partition.


 Practices on – sudo, chown and chmod  ::
 
         Here are some exercises you can try to practice using the sudo, chown, and chmod commands:

        Use the sudo command to execute a command as the root user. For example:

        sudo ls -l /root

        This will list the contents of the /root directory, which is only accessible to the root user.

        Use the chown command to change the owner of a file. For example:

        sudo chown root:root file.txt

        This will change the owner of the file.txt file to the root user.

        Use the chmod command to change the permissions of a file. For example:

        sudo chmod 700 file.txt

        This will set the permissions of the file.txt file to rwx------, which means that only the owner has read, write, 
        and execute permissions.

        Use the chmod command to add or remove permissions for different groups of users. For example:

        sudo chmod g+w file.txt

        This will add write permission for the group owner of the file.txt file.

        sudo chmod o-r file.txt

        This will remove read permission for other users.


Perform adding a user, Delete user, Modify user, Hidden Files ::

        To perform user management tasks such as adding, deleting, and modifying users in a Linux system, you can use the useradd, 
        userdel, and usermod commands.

        Here is an example of how to use these commands:

        Use the useradd command to add a new user. For example:

        sudo useradd -m -s /bin/bash user1

        This will create a new user with a home directory and a default shell of bash.

        Use the userdel command to delete a user. For example:

        sudo userdel user1

        This will delete the user and remove the user's home directory.

        Use the usermod command to modify a user. For example:

        sudo usermod -aG sudo user1

        This will add the user to the sudo group, which allows the user to execute commands with sudo.

        To show hidden files in a Linux system, you can use the ls command with the -a option. This will show all files, including
         hidden files that are prefixed with a ..

        For example: ls -a
        This will show all files in the current directory, including hidden files.


        Hands On Ps command, Top command, Kill command, Expect ::

        Here are some hands-on exercises you can try to practice using the ps, top, kill, and expect commands:

        Use the ps command to list the processes running on the system. For example:

        ps aux

        This will show all processes running on the system, including the process ID, user, and command.

        Use the top command to display the top resource-intensive processes. For example:

        top

        This will show a list of processes sorted by CPU and memory usage.

        Use the kill command to terminate a process. For example:

        kill 12345

        This will send the SIGTERM signal to the process with the ID 12345, which will terminate the process.

        Use the expect command to automate tasks that require interactive input. For example:

        expect -c "spawn ssh user@host
        expect "password:"
        send "mypassword\r"
        expect eof"

        This will log in to the host server as the user user using the ssh command and automatically enter the password when 
        prompted.


Creating scripts (shell & Perl) for various purpose (automation, monitoring, scheduling, etc.,) ::

        To create scripts for various purposes such as automation, monitoring, and scheduling, you can use the Bash shell or 
        a scripting language such as Perl.

        Here is an example of a Bash script that checks the disk usage and sends an email if the usage exceeds a certain threshold:

        #!/bin/bash

        # Check disk usage
        usage=$(df -h / | grep -v "Filesystem" | awk '{print $5}' | sed 's/%//')

        # Send an email if the usage is above the threshold
        if [ $usage -ge 80 ]; then
            echo "Disk usage is high: $usage%" | mail -s "Disk Usage Alert" user@example.com
        fi

        To schedule the script to run automatically, you can use the cron daemon. cron reads the configuration files in the
         /etc/cron.* directories and the /var/spool/cron directory and executes commands at the specified times.

        To schedule the script to run daily at 6:00 am, you can add the following line to the /etc/crontab file:

        0 6 * * * root /path/to/script.sh

        This will run the script.sh script as the root user every day at 6:00 am.

        Here is an example of a Perl script that monitors a log file for specific patterns and sends an alert if a pattern is found:

        #!/usr/bin/perl

        use strict;
        use warnings;

        # Open the log file
        open(my $fh, '<', '/var/log/messages') or die "Cannot open log file: $!";

        # Read the log file line by line
        while (my $line = <$fh>) {
            # Check for the pattern
            if ($line =~ /ERROR/) {
                # Send an alert
                system("echo 'Error found in log file' | mail -s 'Log Alert' user@example.com");
            }
        }

        # Close the log file
        close($fh);

        To run the script automatically at a specific interval, you can use the cron daemon as described above.


Case studies to enhance proficiency in Linux OS and administration. :

        Here are a few case studies that you can use to enhance your proficiency in Linux OS and administration:

        Setting up a web server: In this case study, you can practice setting up a web server using Apache or NGINX, configuring
         virtual hosts, securing the server with SSL certificates, and setting up a database server such as MySQL.

        Building a load-balanced, highly available infrastructure: In this case study, you can practice setting up a load-balanced 
        infrastructure using tools such as HAProxy and keepalived, configuring high availability using tools such as Pacemaker and Corosync, and setting up monitoring using tools such as Nagios.

        Migrating a server to the cloud: In this case study, you can practice migrating a server to the cloud using tools such as
         AWS Server Migration Service or Azure Migrate, configuring networking and security in the cloud, and optimizing the server
         for the cloud environment.

        Setting up a containerized environment: In this case study, you can practice setting up a containerized environment 
        using tools such as Docker, deploying containers using a container orchestration platform such as Kubernetes, and managing 
        the container lifecycle.

        Automating server provisioning and configuration management: In this case study, you can practice using tools such as
         Ansible or Puppet to automate the provisioning and configuration of servers, configuring and managing systems using 
         configuration management tools, and integrating the tools into a continuous delivery pipeline.

        A sample program with error and exception handling written using the Coding standard ::

        Here is a sample program written in C that demonstrates error and exception handling using the C coding standard:

        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <errno.h>

        #define BUFFER_SIZE 1024

        int main(int argc, char *argv[]) {
            char buffer[BUFFER_SIZE];
            FILE *fp;

            if (argc < 2) {
                fprintf(stderr, "Error: missing argument.\n");
                return 1;
            }

            fp = fopen(argv[1], "r");
            if (fp == NULL) {
                fprintf(stderr, "Error opening file: %s\n", strerror(errno));
                return 1;
            }

            while (fgets(buffer, BUFFER_SIZE, fp) != NULL) {
                printf("%s", buffer);
            }

            if (ferror(fp)) {
                fprintf(stderr, "Error reading file: %s\n", strerror(errno));
                fclose(fp);
                return 1;
            }

            fclose(fp);
            return 0;
        }

        The program reads a file specified as a command-line argument and prints its contents to the standard output. 
        It includes error handling for the following cases:

        Missing command-line argument
        Error opening the file
        Error reading the file
        In each case, it prints an error message to the standard error output and returns a non-zero exit status to indicate 
        an error.


Implementing all OOPS concept in the Perl program ::

        Here is an example of a Perl program that demonstrates the implementation of all the object-oriented programming (OOP) 
        concepts:


        #!/usr/bin/perl

        use strict;
        use warnings;

        # Define a class
        package Animal;

        # Constructor
        sub new {
            my ($class, $name, $species) = @_;
            my $self = {
                name => $name,
                species => $species,
            };
            bless $self, $class;
            return $self;
        }

        # Destructor
        sub DESTROY {
            my $self = shift;
            print "$self->{name} has been destroyed.\n";
        }

        # Accessors
        sub get_name {
            my $self = shift;
            return $self->{name};
        }

        sub set_name {
            my ($self, $name) = @_;
            $self->{name} = $name;
        }

        sub get_species {
            my $self = shift;
            return $self->{species};
        }

        sub set_species {
            my ($self, $species) = @_;
            $self->{species} = $species;
        }

        # Method
        sub make_sound {
            my $self = shift;
            print "$self->{name} makes a sound.\n";
        }

        # Inheritance
        package Cat;
        use base qw(Animal);

        # Overriding method
        sub make_sound {
            my $self = shift;
            print "$self->{name} meows.\n";
        }

        # Instantiating objects
        my $animal1 = Animal->new("Fluffy", "Dog");
        my $animal2 = Animal->new("Mittens", "Cat");
        my $cat1 = Cat->new("Whiskers", "Cat");

        # Using accessors
        print $animal1->get_name(), "\n";
        $animal1->set_name("Fido");
        print $animal1->get_name(), "\n";

        # Using method
        $animal1->make_sound();
        $animal2->make_sound();
        $cat1->make_sound();

        # Polymorphism
        my @animals = ($animal1, $animal2, $cat1);

        foreach my $animal (@animals) {
            print $animal->get_name(), " is a ", $animal->get_species(), "\n";
            $animal->make_sound();
        }

        In this program, the Animal class defines a constructor, a destructor, accessors, and a method

        Hands on Working with MySQL and Passing values using HTML form. ::

        Here are some hands-on exercises you can try to practice working with MySQL and passing values using an HTML form:

        Connect to a MySQL database and create a table:

        $ mysql -u username -p
        Enter password:

        mysql> CREATE DATABASE testdb;
        mysql> USE testdb;
        mysql> CREATE TABLE users (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), email VARCHAR(255));
        mysql> INSERT INTO users (name, email) VALUES ('John Smith', 'john@example.com');

        Create an HTML form to input data into the MySQL database:

        <form action="insert.php" method="post">
          Name: <input type="text" name="name"><br>
          Email: <input type="text" name="email"><br>
          <input type="submit" value="Submit">
        </form> 

Create a PHP script to handle the form submission and insert the data into the MySQL database:

        <?php
        $servername = "localhost";
        $username = "username";
        $password = "password";
        $dbname = "testdb";

        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);

        // Check connection
        if ($conn->connect_error) {
            die("Connection failed: " . $conn->connect_error);
        }

        $name = $_POST['name'];
        $email = $_POST['email'];

        $sql = "INSERT INTO users (name, email) VALUES ('$name', '$email')";

        if ($conn->query($sql) === TRUE) {
            echo "New record created successfully";
        } else {
            echo "Error: " . $sql . "<br>" . $conn->error;
        }

        $conn->close();
        ?> 

Writing a program to send an email in perl. ::

        To send an email in Perl, you can use the Net::SMTP module from the Perl standard library. Here is an example of a Perl program that sends an email:


        #!/usr/bin/perl

        use strict;
        use warnings;
        use Net::SMTP;

        # Set up the SMTP server and sender/recipient information
        my $smtp = Net::SMTP->new('smtp.example.com');
        $smtp->mail('sender@example.com');
        $smtp->to('recipient@example.com');

        # Start the message
        $smtp->data();

        # Send the header fields
        $smtp->datasend("To: recipient@example.com\n");
        $smtp->datasend("From: sender@example.com\n");
        $smtp->datasend("Subject: Test Email\n");

        # Send the message body
        $smtp->datasend("\n");
        $smtp->datasend("This is a test email.\n");

        # End the message
        $smtp->dataend();

        # Close the SMTP connection
        $smtp->quit();

        This program connects to the SMTP server at smtp.example.com, sets the sender and recipient, sends a message
         with a subject and body, and then closes the connection.

Writing a program to implement CRUD operation on the file using perl ::
         
        To implement CRUD (create, read, update, delete) operations on a file using Perl, you can use the built-in file
         manipulation functions such as open, read, write, and close. Here is an example of a Perl program that demonstrates 
         the CRUD operations on a file:
         
         #!/usr/bin/perl

        use strict;
        use warnings;

        # Open the file in write mode
        open(my $fh, '>', 'data.txt') or die "Cannot open file: $!";

        # Write to the file
        print $fh "Line 1\n";
        print $fh "Line 2\n";
        print $fh "Line 3\n";

        # Close the file
        close($fh);

        # Open the file in read mode
        open($fh, '<', 'data.txt') or die "Cannot open file: $!";

        # Read the file
        while (my $line = <$fh>) {
            print $line;
        }

        # Close the file
        close($fh);

        # Open the file in append mode
        open($fh, '>>', 'data.txt') or die "Cannot open file: $!";

        # Append to the file
        print $fh "Line 4\n";
        print $fh "Line 5\n";

        # Close the file
        close($fh);

        # Open the file in read mode
        open($fh, '<', 'data.txt') or die "Cannot open file: $!";

        # Read the file
        while (my $line = <$fh>) {
            print $line;
        }

        # Close the file
        close($fh);

        # Open the file in write mode
        open($fh, '>', 'data.txt') or die "Cannot open file: $!";

        # Write to the file
        print $fh "Line




























